# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Linear Regression by Cholesky
#' 
#' Do linear regression of form (X^T O X + P)^{-1} X^T y where O is omega, P is
#' precision. 
#' 
#' @keywords internal
#' 
#' @param X Design Matrix
#' @param omega Polya-Gamma weights
#' @param prior_precision Prior Precision for Regression
#' @param y Outcome
#' @param save_chol
LinRegChol <- function(X, omega, prior_precision, y, save_chol = TRUE) {
    .Call('_vglmer_LinRegChol', PACKAGE = 'vglmer', X, omega, prior_precision, y, save_chol)
}

decomp_calculate_expected_outer_alpha <- function(L, alpha_mu, re_position_list, tP, L_beta, do_adjustment) {
    .Call('_vglmer_decomp_calculate_expected_outer_alpha', PACKAGE = 'vglmer', L, alpha_mu, re_position_list, tP, L_beta, do_adjustment)
}

direct_calculate_expected_outer_alpha <- function(V, alpha_mu, re_position_list) {
    .Call('_vglmer_direct_calculate_expected_outer_alpha', PACKAGE = 'vglmer', V, alpha_mu, re_position_list)
}

#' Conjugate Gradient for Large VI Problems
cg_custom <- function(X, Z, P, omega, ridge_Z, ridge_X, s, offset_ridge_X, old_alpha, tol, it_max = 0L, low_dimension = 5L) {
    .Call('_vglmer_cg_custom', PACKAGE = 'vglmer', X, Z, P, omega, ridge_Z, ridge_X, s, offset_ridge_X, old_alpha, tol, it_max, low_dimension)
}

cpp_inv_alpha_var <- function(diag_vi_pg_mean, P, X, Tinv, vi_Z_list, beta_var_lndet) {
    .Call('_vglmer_cpp_inv_alpha_var', PACKAGE = 'vglmer', diag_vi_pg_mean, P, X, Tinv, vi_Z_list, beta_var_lndet)
}

cpp_quad_collapsed <- function(V, re_position_list, Z_list_raw, individual_assignments, vi_beta_var, P, X) {
    .Call('_vglmer_cpp_quad_collapsed', PACKAGE = 'vglmer', V, re_position_list, Z_list_raw, individual_assignments, vi_beta_var, P, X)
}

cpp_quad_legacy <- function(tZ, varA, tP, X, vi_beta_var) {
    .Call('_vglmer_cpp_quad_legacy', PACKAGE = 'vglmer', tZ, varA, tP, X, vi_beta_var)
}

cpp_var_lp <- function(design_C, vi_C_uncond, vi_M_var, vi_M_list, vi_P, sparse_input, skip_vector) {
    .Call('_vglmer_cpp_var_lp', PACKAGE = 'vglmer', design_C, vi_C_uncond, vi_M_var, vi_M_list, vi_P, sparse_input, skip_vector)
}

cpp_update_m_var <- function(diag_vi_pg_mean, design_C, Tinv_C, list_Tinv_M, vi_M_list, any_collapsed_C, lndet_C) {
    .Call('_vglmer_cpp_update_m_var', PACKAGE = 'vglmer', diag_vi_pg_mean, design_C, Tinv_C, list_Tinv_M, vi_M_list, any_collapsed_C, lndet_C)
}

test_f <- function(diag_vi_pg_mean, design_C, Tinv_C, s, vi_M_list) {
    .Call('_vglmer_test_f', PACKAGE = 'vglmer', diag_vi_pg_mean, design_C, Tinv_C, s, vi_M_list)
}

#' Cyclical Calculation of Variance Decomposition
calculate_alpha_decomp_full_factor <- function(X, Z, P, omega, d_j, g_j, Tinv, re_position_list) {
    .Call('_vglmer_calculate_alpha_decomp_full_factor', PACKAGE = 'vglmer', X, Z, P, omega, d_j, g_j, Tinv, re_position_list)
}

chol_sparse <- function(X, omega, precision) {
    .Call('_vglmer_chol_sparse', PACKAGE = 'vglmer', X, omega, precision)
}

cpp_zVz <- function(Z, V) {
    .Call('_vglmer_cpp_zVz', PACKAGE = 'vglmer', Z, V)
}

cpp_zAz_nonfact <- function(Z, A) {
    .Call('_vglmer_cpp_zAz_nonfact', PACKAGE = 'vglmer', Z, A)
}

vecR_ridge_general <- function(L, pg_mean, Z, M, mapping_J, d, start_z, diag_only) {
    .Call('_vglmer_vecR_ridge_general', PACKAGE = 'vglmer', L, pg_mean, Z, M, mapping_J, d, start_z, diag_only)
}

vecR_design <- function(alpha_mu, Z, M, mapping_J, d, start_z) {
    .Call('_vglmer_vecR_design', PACKAGE = 'vglmer', alpha_mu, Z, M, mapping_J, d, start_z)
}

vecR_fast_ridge <- function(X, omega, prior_precision, y, adjust_y) {
    .Call('_vglmer_vecR_fast_ridge', PACKAGE = 'vglmer', X, omega, prior_precision, y, adjust_y)
}

vecR_ridge_new <- function(L, pg_mean, mapping_J, d, store_id, store_re_id, store_design, diag_only) {
    .Call('_vglmer_vecR_ridge_new', PACKAGE = 'vglmer', L, pg_mean, mapping_J, d, store_id, store_re_id, store_design, diag_only)
}

